# redis-mq-playground

## demo1 基于 List

List 是 Redis 中提供的基本数据结构之一，可以通过其提供的 LPUSH 和 BRPOP 等命令来实现消息队列的入队和出队操作。

优点：

- 实现简单，易于上手。
- 使用方便，性能较好。

缺点：

- 当队列数据量较大时，出队操作性能会降低。
- 不支持对消息进行优先级排序。

## demo2 基于 Sorted-Set

通过使用 Sorted-Set 数据结构，可以为消息设置分数（score），利用分数进行排序。

优点：

- 支持对消息进行优先级排序。
- 出队操作性能相对较好。

缺点：

- 需要额外处理消息的唯一性，以及相同优先级消息的顺序。
- 需要在代码中处理分数的设置和维护。

## demo3 基于 Pub/Sub

Redis 的发布/订阅机制，可以让订阅者接收发布者发送的消息，实现异步消息广播。

优点：

- 支持一对多的消息订阅和发布。
- 可以实现实时消息推送。

缺点：

- 不适合处理持久化消息，因为订阅者需要在线才能接收消息，否则会错过消息。
- 不支持消息的持久化和重发机制。

## demo4 基于 Stream

Redis 5.0 引入的数据结构，用于处理消息流，支持消息持久化和消费者分组。

优点：

- 支持消息的持久化和重发机制。
- 支持多个消费者进行分组消费。

缺点：

- 相对较新的特性，可能需要升级 Redis 版本。
- 在低版本 Redis 中不可用。

## Redis MQ 的缺点

理清是 mq 的核心功能和诉求后，下面我们先明确一下基于 redis 实现 mq 存在的一类通用问题：

**存储昂贵**

redis 本身是基于内存实现的缓存组件，因此在存储消息时总容量相对有限.

**数据丢失**

此外，redis 存储消息时会不可避免地存在数据丢失的风险，可以从两个方面出发考虑：

- 内存是易失性存储.即便 redis 中有 rdb/aof 之类的持久化机制加以弥补，但这个持久化流程是异步执行的，无法提供百分百的保证力度

- redis 走的是 ap 高可用流派，数据的主从复制流程是异步执行的，主从切换时数据存在弱一致问题

以上问题，不论是在 redis 缓存数据还是实现 mq 的流程中都是存在的，这个问题我们在选型使用 redis 时需要做到了然于心，这一点在后续 4.3 小节中会进一步展开说明。

## RabbitMQ 和 Redis 对比

RabbitMQ 和 Redis 都是流行的消息队列（MQ）中间件解决方案，它们都提供了在应用程序之间进行异步消息传递的功能。然而，它们在实现 MQ 方面有一些关键的区别。

RabbitMQ 是一个开源的消息代理，它实现了高级消息排队和发布/订阅模式。它是基于 AMQP（高级消息队列协议）的，支持复杂的消息路由和消息的持久化，适用于需要强大消息队列特性的企业级应用。

Redis 是一个开源的内存数据存储解决方案，虽然它也可以用作消息队列，但是它更适合于缓存和数据库的持久化。Redis 的发布/订阅功能使其可以处理简单的消息队列需求，但是它不支持高级的消息路由和队列持久化。

以下是一些比较 RabbitMQ 和 Redis 在实现 MQ 方面的关键区别：

**消息持久化**：

- RabbitMQ 支持消息的持久化，即使代理重启，消息也不会丢失。这对于对消息可靠性有要求的应用程序很重要。
- Redis 在默认情况下将消息存储在内存中，可以通过配置将消息持久化到磁盘，但是对于高可靠性的消息传递，它的持久化能力相对较弱。

**消息路由和模式**：

- RabbitMQ 基于 AMQP 协议，支持复杂的消息路由、交换器和队列绑定。它可以实现灵活的消息处理逻辑。
- Redis 的发布/订阅功能相对简单，对于需要高级消息路由和模式的场景可能会显得不够灵活。

**性能**：

- Redis 作为内存数据库，具有很高的读写性能，适合轻量级的消息队列需求。
- RabbitMQ 针对企业级应用场景进行了优化，提供了更多的管理和控制功能，适合于复杂的消息处理需求。

根据的具体需求可以选择 RabbitMQ 或 Redis 来实现消息队列。如果需要复杂的消息路由和持久化，以及对消息可靠性有要求，那么 RabbitMQ 可能更适合。如果场景更加轻量级且对性能有要求，那么 Redis 也是一个很好的选择。
